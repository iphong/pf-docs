# Apply the OOP concept to refactor PageFly

Functional programming and object-oriented programming are two different techniques. So, to refactor PageFly applying OOP, I've created a new structure. Besides the new structure, I've also created some adapters for a seamless combination of refactored and non-refactored code. The adapters will ensure PageFly functions like normal while being refactored.

In the new structure, the data manipulation mechanism is encapsulated based on class instantiation instead of via a variable containing a global state created by calling the `createSubscription` function. The reason is a variable can easily change without notice. This behavior causes the data to become insecure. The new mechanism requires getting an instance of storage before being able to manipulate data by using a set of predefined methods. This behavior adds a boundary to secure the data and make every change to data trackable. [You can read details about the new storage mechanism on this page](storage-mechanism.md).

To optimize the loading trunk of the app, I've created a React component that supports rendering another React component dynamically. The `Render` component will load the declaration of a React component only when the UI contains that component. This behavior can reduce the size of the main trunk. [You can read details about the `Render` component on this page](dynamic-render.md).

The dynamic rendering mechanism will work most effectively when all the UI components are encapsulated. To promote the encapsulation, I've created the `Component` class as a base for building UI components. UI components that extend the base component will automatically inherit initialization, reactivation, and destruction made by the base class. Subclasses only need to manage the internal state to render the appropriate content. [You can read details about the base class `Component` and how to refactor current UI components on this page](refactor-ui-components.md).

The heart of PageFly is the ability to build web pages. This feature mostly depends on the editor and the inspector module. Currently, these modules strongly couple together. This situation causes both of them to depend on each other. This behavior causes code complexity, and the reusability of the inspector module is low. For example, when using the inspector module on the global styling screen, many existing input controls must be rewritten to work as intended. This situation causes code duplication and increases the overall size of the app. Therefore, I've created new structures and mechanisms for the editor and the inspector module to separate them. You can read details about the new structure and how to refactor the editor module [on this page](refactor-the-editor-module.md) and the inspector module [on this page](refactor-the-inspector-module.md).
