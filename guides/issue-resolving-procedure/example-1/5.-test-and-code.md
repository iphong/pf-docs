---
description: >-
  Display a survey to PageFly users to collect their needs for the Black Friday
  campaign.
---

# 5. Test and code

Suppose that the time-to-market of the request to _“display a survey to PageFly users to collect their needs for the Black Friday campaign”_ is not too close, which allows having enough time to implement the simplest and most effective solution ([the third solution](3.-choose-one-solution.md#evaluate-the-third-solution)).

First, we will declare schemas for two collections, one for saving surveys and the other for saving user responses. Schema is the structure that we store data in the database so testing it is unnecessary. Hence, let's do it before creating the first test script.

{% hint style="info" %}
Because we have to pay the MongoDB cloud service for the amount of stored data, let's make the data structure as lean as possible by keeping the relationship between documents and collections straightforward and avoiding data duplication.
{% endhint %}

<details>

<summary>[pfserver] src/data/models/Survey.ts</summary>

```typescript
import mongoose, {Document} from 'mongoose'

// Define document type.
export type SurveyType = {
  _id: string
  title: string
  description?: string
  questions: [
    {
      _id: string
      type: 'text' | 'radio' | 'checkbox'
      question: string
      // Predefined answers are only required if the `type` is not 'text'.
      answers?: [
        {
          _id: string
          answer: string
        },
      ]
    },
  ]
  status: 'active' | 'inactive'
  // If both `startTime` and `endTime` are undefined, the survey will
  // always be visible until its `status` is set to 'inactive'.
  startTime?: Date
  endTime?: Date
  // If `includeLocations` is undefined, the survey will be visible in
  // all locations except locations defined for `excludeLocations`.
  includeLocations?: string[]
  // If `excludeLocations` is defined, the survey will be invisible in
  // all locations defined for `excludeLocations`.
  excludeLocations?: string[]
}

// Define model schema.
const surveySchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
      index: true,
    },
    description: String,
    questions: [
      {
        _id: mongoose.Schema.Types.ObjectId,
        type: {
          type: String,
          enum: ['text', 'radio', 'checkbox'],
          required: true,
          index: true,
        },
        question: {
          type: String,
          required: true,
          index: true,
        },
        // Predefined answers are only required if the `type` is not 'text'.
        answers: [
          {
            _id: mongoose.Schema.Types.ObjectId,
            answer: {
              type: String,
              required: true,
              index: true,
            },
          },
        ],
      },
    ],
    status: {
      type: String,
      enum: ['active', 'inactive'],
      default: 'inactive',
      index: true,
    },
    // If both `startTime` and `endTime` are undefined, the survey will
    // always be visible until its `status` is set to 'inactive'.
    startTime: {
      type: Date,
      index: true,
    },
    endTime: {
      type: Date,
      index: true,
    },
    // If `includeLocations` is undefined, the survey will be visible in
    // all locations except locations defined for `excludeLocations`.
    includeLocations: [
      {
        type: String,
        index: true,
      },
    ],
    // If `excludeLocations` is defined, the survey will be invisible in
    // all locations defined for `excludeLocations`.
    excludeLocations: [
      {
        type: String,
        index: true,
      },
    ],
  },
  {timestamps: true}
)

surveySchema.pre('save', async function (next) {
  // Automatically generate `_id` for questions and answers.
  this.questions.forEach((question, qIndex) => {
    if (!question._id) {
      this.questions[qIndex]._id = new mongoose.Types.ObjectId()
    }

    question.answers.forEach((answer, aIndex) => {
      if (!answer._id) {
        this.questions[qIndex].answers[aIndex]._id = new mongoose.Types.ObjectId()
      }
    })
  })

  next()
})

const SurveyModel = mongoose.model<Document & SurveyType>('Survey', surveySchema)

export default SurveyModel
```

</details>

<details>

<summary>[pfserver] src/data/models/SurveyResponse.ts</summary>

````typescript
```typescript
import mongoose, {Document} from 'mongoose'

// Define document type.
export type SurveyResponseType = {
  _id?: string
  surveyId: string
  shopDomain?: string
  responses: {
    questionId: string
    // Answer ID is only available if the question `type` is not 'text'.
    answerId?: string[]
    // Text answer is only available if the question `type` is 'text'.
    textAnswer?: string
  }[]
}

// Define model schema.
const surveyResponseSchema = new mongoose.Schema(
  {
    surveyId: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      index: true,
      ref: 'Survey',
    },
    shopDomain: {
      type: String,
      required: true,
      index: true,
      ref: 'Shop',
    },
    responses: [{
      questionId: mongoose.Schema.Types.ObjectId,
      // Answer ID is only available if the question `type` is not 'text'.
      answerId: [mongoose.Schema.Types.ObjectId],
      // Text answer is only available if the question `type` is 'text'.
      textAnswer: String,
    }],
  },
  { timestamps: true }
)

const SurveyResponseModel = mongoose.model<Document & SurveyResponseType>('SurveyResponse', surveyResponseSchema)

export default SurveyResponseModel
````

</details>

As you can see, the `SurveyResponse` model does not save any data saved in the `Survey` model except for ID-related properties. By doing that, we can avoid data duplication. Additionally, I have created indexes for properties that can be used as criteria for searching. This can shorten the time needed for querying specific documents.

It's time to create our first test script for the most basic test case on the server side, _"there are some surveys in the database but no survey is active, the server endpoint for getting survey data must return an empty array"_, in the list of test cases we created in [step 4](4.-write-test-cases.md).

{% hint style="info" %}
If you have not set up your local development environment for automated tests yet, [click here](../../test-driven-development-tdd.md#set-things-up) for how to do it.
{% endhint %}

When everything is ready, let's create a test script for the first test case related to the `pfserver` project: _There are some surveys in the database but no survey is active, the server endpoint for getting survey data must return an empty array_.

<details>

<summary>[pfserver] src/__<strong>tests__</strong>/routers/api/survey.test.ts</summary>

```typescript
import 'dotenv/config'
import request from 'supertest'
import mongoose from 'mongoose'
import { PageFlyServer } from '../../../server'
import SurveyModel from '../../../data/models/Survey'
import PageFlyShopifyHandler from '../../../handlers/shopify'

describe('test the server endpoint for getting survey data', () => {
  let server, handler, agent

  beforeAll(async () => {
    // Connect Mongoose to MongoDB.
    await mongoose.connect(process.env.MONGODB_URI_FOR_AUTOMATED_TESTS, { keepAlive: true })

    // Fake some environment variables.
    process.env.CATALOG_DATA_IMPORTED = 'yes'

    // Init PageFly server.
    server = new PageFlyServer()
    handler = new PageFlyShopifyHandler(server.app, null)

    handler.initRouting()

    // Init an agent for testing.
    agent = request.agent(server.app)

    // Clear mock data.
    await SurveyModel.deleteMany({})
  })

  afterAll(async () => {
    // Clear mock data.
    await SurveyModel.deleteMany({})

    // Disconnect from MongoDB.
    await mongoose.connection.close()
  })

  it('should return empty array if there are some surveys in the database but no survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 1',
        questions: [
          {
            type: 'text',
            question: 'How are you today?'
          }
        ],
        status: 'inactive'
      },
      {
        title: 'Survey 2',
        questions: [
          {
            type: 'text',
            question: 'How can I help you today?'
          }
        ],
        status: 'inactive'
      },
    ])

    // Send a GET request to the API endpoint.
    const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(0)
  })
})
```

</details>

If you have not started an automated test session yet, run the following command in the terminal to start one.

```sh
yarn cross-env NODE_ENV=test jest survey.test.ts --testTimeout=5000 --watchAll --detectOpenHandles
```

You will see the following text printed on the terminal.

```
 FAIL  src/__tests__/routers/api/survey.test.ts (5.396 s)
  test the server endpoint for getting survey data
    ✕ should return empty array if there are some surveys in the database but no survey is active (302 ms)

  ● test the server endpoint for getting survey data › should return empty array if there are some surveys in the database but no survey is active

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: undefined

      62 |     const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')
      63 |
    > 64 |     expect(res.body.success).toBe(1)
         |                              ^
      65 |     expect(res.body.surveys.length).toBe(0)
      66 |   })
      67 | })

      at Object.<anonymous> (src/__tests__/routers/api/survey.test.ts:64:30)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        5.44 s
Ran all test suites matching /survey.test.ts/i.

Active Filters: filename /survey.test.ts/
 › Press c to clear filters.

Watch Usage
 › Press f to run only failed tests.
 › Press o to only run tests related to changed files.
 › Press q to quit watch mode.
 › Press i to run failing tests interactively.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press Enter to trigger a test run.
```

The automated test session is ready now, let's create a server endpoint for getting survey data to pass the first test case and then refactor it to standards.

<details>

<summary>[pfserver] src/routers/api/survey.ts</summary>

```typescript
import ShopModel from '../../data/models/Shop'
import SurveyModel from '../../data/models/Survey'
import {NextFunction, Request, Response} from 'express'

export async function handleGet(req: Request, res: Response, next?: NextFunction) {
  try {
    // Define query for getting active surveys.
    const query = { status: 'active' }

    // Query for active surveys.
    const surveys = await SurveyModel.find(query, '_id title description questions')

    res.status(200).json({success: 1, surveys})
  } catch (e) {
    res.status(500).json({success: 0, message: e.message || e})
  }
}
```

</details>

Switch to the terminal where you started the automated test session, you will see the following test result.

```
 PASS  src/__tests__/routers/api/survey.test.ts
  test the server endpoint for getting survey data
    ✓ should return empty array if there are some surveys in the database but no survey is active (699 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        2.26 s
Ran all test suites matching /survey.test.ts/i.

Watch Usage: Press w to show more.
```

Now, continue to write another test script for the second test case related to the `pfserver` project: _There are some surveys in the database but only one survey is active, the server endpoint for getting survey data must return only the active survey as an array with a single item_.

<details>

<summary>[pfserver] src/__<strong>tests__</strong>/routers/api/survey.test.ts</summary>

```typescript
import 'dotenv/config'
import request from 'supertest'
import mongoose from 'mongoose'
import { PageFlyServer } from '../../../server'
import ShopModel from '../../../data/models/Shop'
import SurveyModel from '../../../data/models/Survey'
import PageFlyShopifyHandler from '../../../handlers/shopify'

describe('test the server endpoint for getting survey data', () => {
  let server, handler, agent

  beforeAll(async () => {
    // Connect Mongoose to MongoDB.
    await mongoose.connect(process.env.MONGODB_URI_FOR_AUTOMATED_TESTS, { keepAlive: true })

    // Fake some environment variables.
    process.env.CATALOG_DATA_IMPORTED = 'yes'

    // Init PageFly server.
    server = new PageFlyServer()
    handler = new PageFlyShopifyHandler(server.app, null)

    handler.initRouting()

    // Init an agent for testing.
    agent = request.agent(server.app)

    // Clear mock data.
    await SurveyModel.deleteMany({})
  })

  afterAll(async () => {
    // Clear mock data.
    await SurveyModel.deleteMany({})

    // Disconnect from MongoDB.
    await mongoose.connection.close()
  })

  it('should return empty array if there are some surveys in the database but no survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 1',
        questions: [
          {
            type: 'text',
            question: 'How are you today?'
          }
        ],
        status: 'inactive'
      },
      {
        title: 'Survey 2',
        questions: [
          {
            type: 'text',
            question: 'How can I help you today?'
          }
        ],
        status: 'inactive'
      },
    ])

    // Send a GET request to the API endpoint.
    const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(0)
  })

  it('should return only the active survey as an array with a single item if there are some surveys in the database but only one survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 3',
        questions: [
          {
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active'
      },
    ])

    // Send a GET request to the API endpoint.
    let res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in a specified time range.
    await SurveyModel.insertMany([
      {
        title: 'Survey 3',
        questions: [
          {
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active',
        endTime: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 4',
        questions: [
          {
            type: 'text',
            question: 'What is your opinion for Black Friday campaign?'
          }
        ],
        status: 'active',
        includeLocations: ['US'],
      },
    ])

    await ShopModel.updateOne(
      { shopDomain: 'cuongnm-dev-store.myshopify.com' },
      { metadata: { country_code: 'VN' } },
      { upsert: true }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active all locations except specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 4',
        questions: [
          {
            type: 'text',
            question: 'What is your plan for Christmas Eve?'
          }
        ],
        status: 'active',
        excludeLocations: ['VN'],
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)
  })
})
```

</details>

Again, the new test fails and we need to update the server endpoint for getting survey data as follows to pass the test.

<details>

<summary>[pfserver] src/routers/api/survey.ts</summary>

```typescript
import ShopModel from '../../data/models/Shop'
import SurveyModel from '../../data/models/Survey'
import {NextFunction, Request, Response} from 'express'

export async function handleGet(req: Request, res: Response, next?: NextFunction) {
  try {
    // Get current time.
    const now = new Date()

    // Get the current shop location.
    const {shop: shopDomain} = req.session
    const shopData = await ShopModel.findOne({shopDomain})
    const shopLocation = shopData?.metadata?.country_code

    // Define query for getting active surveys.
    const query = {
      $and: [
        // Has active status.
        {status: 'active'},
        // Has start time undefined or earlier than the current time.
        {
          $or: [
            { startTime: null },
            { startTime: { $exists: false } },
            { startTime: { $lt: now } },
          ],
        },
        // Has end time undefined or later than the current time.
        {
          $or: [
            { endTime: null },
            { endTime: { $exists: false } },
            { endTime: { $gt: now } },
          ],
        },
        // Has included location undefined or includes the shop location.
        {
          $or: [
            { includeLocations: null },
            { includeLocations: { $exists: false } },
            { includeLocations: { $size: 0 } },
            { includeLocations: shopLocation },
          ],
        },
        // Has excluded location undefined or not includes the shop location.
        {
          $or: [
            { excludeLocations: null },
            { excludeLocations: { $exists: false } },
            { excludeLocations: { $size: 0 } },
            { excludeLocations: { $nin: [shopLocation] } },
          ],
        },
      ],
    }

    // Query for active surveys.
    const surveys = await SurveyModel.find(query, '_id title description questions')

    res.status(200).json({success: 1, surveys})
  } catch (e) {
    res.status(500).json({success: 0, message: e.message || e})
  }
}
```

</details>

We will continue to write a new test script for the third test case related to the `pfserver` project: _There are several active surveys in the database, the server endpoint for getting survey data must return all the active surveys as an array_.

<details>

<summary>[pfserver] src/__<strong>tests__</strong>/routers/api/survey.test.ts</summary>

```typescript
import 'dotenv/config'
import request from 'supertest'
import mongoose from 'mongoose'
import { PageFlyServer } from '../../../server'
import ShopModel from '../../../data/models/Shop'
import SurveyModel from '../../../data/models/Survey'
import PageFlyShopifyHandler from '../../../handlers/shopify'

describe('test the server endpoint for getting survey data', () => {
  let server, handler, agent

  beforeAll(async () => {
    // Connect Mongoose to MongoDB.
    await mongoose.connect(process.env.MONGODB_URI_FOR_AUTOMATED_TESTS, { keepAlive: true })

    // Fake some environment variables.
    process.env.CATALOG_DATA_IMPORTED = 'yes'

    // Init PageFly server.
    server = new PageFlyServer()
    handler = new PageFlyShopifyHandler(server.app, null)

    handler.initRouting()

    // Init an agent for testing.
    agent = request.agent(server.app)

    // Clear mock data.
    await SurveyModel.deleteMany({})
  })

  afterAll(async () => {
    // Clear mock data.
    await SurveyModel.deleteMany({})

    // Disconnect from MongoDB.
    await mongoose.connection.close()
  })

  it('should return empty array if there are some surveys in the database but no survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 1',
        questions: [
          {
            type: 'text',
            question: 'How are you today?'
          }
        ],
        status: 'inactive'
      },
      {
        title: 'Survey 2',
        questions: [
          {
            type: 'text',
            question: 'How can I help you today?'
          }
        ],
        status: 'inactive'
      },
    ])

    // Send a GET request to the API endpoint.
    const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(0)
  })

  it('should return only the active survey as an array with a single item if there are some surveys in the database but only one survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 3',
        questions: [
          {
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active'
      },
    ])

    // Send a GET request to the API endpoint.
    let res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in a specified time range.
    await SurveyModel.insertMany([
      {
        title: 'Survey 4',
        questions: [
          {
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active',
        endTime: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 5',
        questions: [
          {
            type: 'text',
            question: 'What is your opinion for Black Friday campaign?'
          }
        ],
        status: 'active',
        includeLocations: ['US'],
      },
    ])

    await ShopModel.updateOne(
      { shopDomain: 'cuongnm-dev-store.myshopify.com' },
      { metadata: { country_code: 'VN' } },
      { upsert: true }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in all locations except specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 6',
        questions: [
          {
            type: 'text',
            question: 'What is your plan for Christmas Eve?'
          }
        ],
        status: 'active',
        excludeLocations: ['VN'],
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)
  })

  it('should return all the active surveys as an array if there are several active surveys in the database', async () => {
    // Update mock data to test survey active in a specified time range..
    await SurveyModel.updateOne(
      { title: 'Survey 4' },
      {
        startTime: new Date(Date.now() - 24 * 60 * 60 * 1000),
        endTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
      }
    )

    // Send a GET request to the API endpoint.
    let res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(2)

    // Update mock data to test survey active in specified locations.
    await SurveyModel.updateOne(
      { title: 'Survey 5' },
      { includeLocations: ['VN'] }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(3)

    // Update mock data to test survey active in all locations except specified locations.
    await SurveyModel.updateOne(
      { title: 'Survey 6' },
      { excludeLocations: ['US'] }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(4)
  })
})
```

</details>

Luckily, the new test automatically passes because we already handle that case in the code of the server endpoint for getting survey data.

Repeat the cycle we've done above for the remaining test cases related to the `pfserver` project until all test cases pass. Below is the final results.

{% tabs %}
{% tab title="First Tab" %}

{% endtab %}

{% tab title="Second Tab" %}

{% endtab %}
{% endtabs %}

That's enough for the server side. It's time to write code for the client side.

Because stakeholders might want to display the survey in multiple places, We will create storage to save the survey content instead of storing it in the component state. The storage below extends the base storage class I created in [this proposal](../../refactor-pagefly-applying-oop/apply-the-oop-concept-to-refactor-pagefly/storage-mechanism.md).

If you want, you can create storage the way you like. But, make sure that every component needs to access and mutate the data via predefined methods bound to the data instead of the direct way via object properties. This behavior ensures the safety of the data.

<details>

<summary>[pfcore] src/next/modules/survey/constant.ts</summary>

```typescript
export const SURVEY_API_ENDPOINT = '/api/survey'
```

</details>

<details>

<summary>[pfcore] src/next/modules/survey/storage.ts</summary>

```typescript
import Storage from '@/@refactoring/includes/storage'
import { SURVEY_API_ENDPOINT } from '@/modules/survey/constant'

export type SurveyDataType = {
  surveys: {
    _id: string
    title: string
    description: string
    questions: [{
      _id: string
      type: 'text' | 'radio' | 'checkbox'
      question: string
      // Predefined answers are only required if the `type` is not 'text'.
      answers?: [{
        _id: string
        answer: string
      }]
    }]
  }[]
}

/**
 * Define storage for storing survey data.
 */
export default class SurveyStorage extends Storage<SurveyDataType, SurveyDataType> {
  // Define API endpoints for requesting data.
  static syncWithServerURL = SURVEY_API_ENDPOINT
}
```

</details>

Everything is ready now. Finally, we will create a stand-alone UI component to display active surveys. Again, I will extend the base component class I created in [this proposal](../../refactor-pagefly-applying-oop/apply-the-oop-concept-to-refactor-pagefly/refactor-ui-components.md).

If you want, you can create UI components the way you like. But, make sure that the UI component does not rely on other functionalities to work as intended. It also must not affect other functionalities of the app.

<details>

<summary>[pfcore] src/next/modules/survey/index.tsx</summary>

```typescript
import Component, { StringMapping } from '@/@refactoring/includes/component'
import SurveyStorage, { SurveyDataType } from '@/modules/survey/storage'
import { t } from 'i18next'
import { debounce } from 'lodash'
import { ReactNode } from 'react'
import { Modal } from '@shopify/polaris'
import { SURVEY_API_ENDPOINT } from '@/modules/survey/constant'
import { fetchWithSessionToken } from '@/views/embed/session-token-helper'

type SurveyPropsType = {
  visible?: boolean
  activator?: ReactNode
}

type SurveyStateType = SurveyDataType & {
  visible: boolean
  currentSurveyIndex: number
}

type UserResponseType = {
  [surveyId: string]: {
    answers: {
      [questionId: string]: {
        // Answer ID is only available if the question `type` is not 'text'.
        answerId?: string[]
        // Text answer is only available if the question `type` is 'text'.
        textAnswer?: string
      }
    }
  }
}

export default class Survey extends Component<SurveyPropsType, SurveyStateType> {
  // Define storage to populate component state from in `defaultProps`.
  static defaultProps = {
    storages: [SurveyStorage]
  }

  // Define mapping from storage data to component state.
  static storageToState: StringMapping = { 'SurveyStorage.surveys': 'surveys' }

  // Define the initial component state.
  state: SurveyStateType = { surveys: [], visible: true, currentSurveyIndex: 0 }

  // Define a variable to hold user responses.
  responses: UserResponseType = {}

  constructor(props) {
    super(props)

    // Populate initial state.
    if (props.visible !== undefined) {
      this.state.visible = props.visible
    }
  }

  /**
   * Method to close the survey modal.
   */
  closeModal = () => this.setState({ visible: false })

  /**
   * Method to POST user responses to server.
   */
  saveUserResponses = () => {
    // Send user responses to the server.
    if (Object.keys(this.responses).length) {
      fetchWithSessionToken(SURVEY_API_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ data: this.responses })
      })
        .catch(console.error)
    }

    // Close the survey modal.
    this.closeModal()
  }

  /**
   * Method to handle changes in form fields.
   */
  handleChange = debounce(e => {
    const { surveys, currentSurveyIndex } = this.state

    // Update user responses.
    const surveyId = surveys[currentSurveyIndex]._id
    const questionId = e.target.name

    if (!this.responses[surveyId]) {
      this.responses[surveyId] = { answers: {} }
    }

    if (e.target.type === 'text') {
      this.responses[surveyId].answers[questionId] = { textAnswer: e.target.value }
    } else {
      if (!this.responses[surveyId].answers[questionId]) {
        this.responses[surveyId].answers[questionId] = { answerId: [] }
      }

      if (e.target.type === 'radio') {
        this.responses[surveyId].answers[questionId].answerId = [e.target.value]
      } else {
        // Handle checkboxes.
        if (e.target.checked) {
          if (!this.responses[surveyId].answers[questionId].answerId.includes(e.target.value)) {
            this.responses[surveyId].answers[questionId].answerId.push(e.target.value)
          }
        } else  {
          const index = this.responses[surveyId].answers[questionId].answerId.indexOf(e.target.value)

          if (index > -1) {
            this.responses[surveyId].answers[questionId].answerId.splice(index, 1)
          }
        }
      }
    }
  }, 200)

  render(): ReactNode {
    const { activator } = this.props
    const { surveys, visible, currentSurveyIndex } = this.state

    if (!surveys?.length || !visible && !activator) {
      return null
    }

    const currentSurvey = surveys[currentSurveyIndex]

    return <>
      {activator && <a href="#survey" onClick={() => this.setState({ visible: !visible })}>
        {activator}
      </a>}
      <Modal
        open={visible}
        onClose={this.closeModal}
        title={currentSurvey.title}
        primaryAction={{
          content: t('SAVE'),
          onAction: this.saveUserResponses,
        }}
        secondaryActions={[
          ...(surveys.length > 1 ? [
            {
              content: '<',
              disabled: currentSurveyIndex === 0,
              onAction: () => this.setState({ currentSurveyIndex: currentSurveyIndex - 1 }),
            },
            {
              content: '>',
              disabled: currentSurveyIndex === surveys.length - 1,
              onAction: () => this.setState({ currentSurveyIndex: currentSurveyIndex + 1 }),
            },
          ] : []),
          {
            content: t('CANCEL'),
            onAction: this.closeModal,
          },
        ]}
      >
        <form onSubmit={e => e.preventDefault()}>
          {currentSurvey.description && <legend>{currentSurvey.description}</legend>}
          {currentSurvey.questions.map(question => {
            const response = this.responses[currentSurvey._id]?.answers?.[question._id]

            return <div key={question._id}>
              <label>{question.question}</label>
              {
                question.type === 'text'
                  ? <input
                    type="text"
                    name={question._id}
                    onChange={this.handleChange}
                    defaultValue={response?.textAnswer}
                  />
                  : question.answers.map(answer => <div>
                    <input
                      value={answer._id}
                      name={question._id}
                      type={question.type}
                      onChange={this.handleChange}
                      defaultChecked={response?.answerId?.includes(answer._id)}
                    />
                    <span>{answer.answer}</span>
                  </div>)
              }
            </div>
          })}
        </form>
      </Modal>
    </>
  }
}
```

</details>

Now, we have a module dedicated to displaying surveys and collecting user responses. If stakeholders want the survey to show automatically on certain screens, you can place the JSX tag `<Survey />` at the appropriate positions in the code base. On the other hand, if stakeholders want to show a link somewhere that when clicking on will open the survey, you can use the JSX tag `<Survey visible={false} activator="Open survey" />`.

Last but not least, we need to create a screen in AC2 to display user responses to stakeholders and another screen to allow stakeholders to update or remove surveys or create a new survey.

|                            Current step                           |
| :---------------------------------------------------------------: |
| [5.-test-and-code.md](../processes/5.-test-and-code.md "mention") |
