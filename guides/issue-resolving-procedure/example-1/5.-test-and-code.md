---
description: >-
  Display a survey to PageFly users to collect their needs for the Black Friday
  campaign.
---

# 5. Test and code

Suppose that the time-to-market of the request to _“display a survey to PageFly users to collect their needs for the Black Friday campaign”_ is not too close, which allows having enough time to implement the simplest and most effective solution ([the third solution](3.-choose-one-solution.md#evaluate-the-third-solution)).

First, we will declare schemas for two collections, one for saving surveys and the other for saving user responses. Schema is the structure that we store data in the database so testing it is unnecessary. Hence, let's do it before creating the first test script.

{% hint style="info" %}
Because we have to pay the MongoDB cloud service for the amount of stored data, let's make the data structure as lean as possible by keeping the relationship between documents and collections straightforward and avoiding data duplication.
{% endhint %}

<details>

<summary>[pfserver] src/data/models/Survey.ts</summary>

```typescript
import mongoose, {Document} from 'mongoose'

// Define document type.
export type SurveyType = {
  _id: string
  title: string
  description?: string
  questions: [
    {
      _id: string
      type: 'text' | 'radio' | 'checkbox'
      question: string
      // Predefined answers are only required if the `type` is not 'text'.
      answers?: [
        {
          _id: string
          answer: string
        },
      ]
    },
  ]
  status: 'active' | 'inactive'
  // If both `startTime` and `endTime` are undefined, the survey will
  // always be visible until its `status` is set to 'inactive'.
  startTime?: Date
  endTime?: Date
  // If `includeLocations` is undefined, the survey will be visible in
  // all locations except locations defined for `excludeLocations`.
  includeLocations?: string[]
  // If `excludeLocations` is defined, the survey will be invisible in
  // all locations defined for `excludeLocations`.
  excludeLocations?: string[]
}

// Define model schema.
const surveySchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
      index: true,
    },
    description: String,
    questions: [
      {
        _id: mongoose.Schema.Types.ObjectId,
        type: {
          type: String,
          enum: ['text', 'radio', 'checkbox'],
          required: true,
          index: true,
        },
        question: {
          type: String,
          required: true,
          index: true,
        },
        // Predefined answers are only required if the `type` is not 'text'.
        answers: [
          {
            _id: mongoose.Schema.Types.ObjectId,
            answer: {
              type: String,
              required: true,
              index: true,
            },
          },
        ],
      },
    ],
    status: {
      type: String,
      enum: ['active', 'inactive'],
      default: 'inactive',
      index: true,
    },
    // If both `startTime` and `endTime` are undefined, the survey will
    // always be visible until its `status` is set to 'inactive'.
    startTime: {
      type: Date,
      index: true,
    },
    endTime: {
      type: Date,
      index: true,
    },
    // If `includeLocations` is undefined, the survey will be visible in
    // all locations except locations defined for `excludeLocations`.
    includeLocations: [
      {
        type: String,
        index: true,
      },
    ],
    // If `excludeLocations` is defined, the survey will be invisible in
    // all locations defined for `excludeLocations`.
    excludeLocations: [
      {
        type: String,
        index: true,
      },
    ],
  },
  {timestamps: true}
)

surveySchema.pre('save', async function (next) {
  // Automatically generate `_id` for questions and answers.
  this.questions.forEach((question, qIndex) => {
    if (!question._id) {
      this.questions[qIndex]._id = new mongoose.Types.ObjectId()
    }

    question.answers.forEach((answer, aIndex) => {
      if (!answer._id) {
        this.questions[qIndex].answers[aIndex]._id = new mongoose.Types.ObjectId()
      }
    })
  })

  next()
})

const SurveyModel = mongoose.model<Document & SurveyType>('Survey', surveySchema)

export default SurveyModel
```

</details>

<details>

<summary>[pfserver] src/data/models/SurveyResponse.ts</summary>

````typescript
```typescript
import mongoose, {Document} from 'mongoose'

// Define document type.
export type SurveyResponseType = {
  _id?: string
  surveyId: string
  shopDomain?: string
  responses: {
    questionId: string
    // Answer ID is only available if the question `type` is not 'text'.
    answerId?: string[]
    // Text answer is only available if the question `type` is 'text'.
    textAnswer?: string
  }[]
}

// Define model schema.
const surveyResponseSchema = new mongoose.Schema(
  {
    surveyId: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      index: true,
      ref: 'Survey',
    },
    shopDomain: {
      type: String,
      required: true,
      index: true,
      ref: 'Shop',
    },
    responses: [{
      questionId: mongoose.Schema.Types.ObjectId,
      // Answer ID is only available if the question `type` is not 'text'.
      answerId: [mongoose.Schema.Types.ObjectId],
      // Text answer is only available if the question `type` is 'text'.
      textAnswer: String,
    }],
  },
  { timestamps: true }
)

const SurveyResponseModel = mongoose.model<Document & SurveyResponseType>('SurveyResponse', surveyResponseSchema)

export default SurveyResponseModel
````

</details>

As you can see, the `SurveyResponse` model does not save any data saved in the `Survey` model except for ID-related properties. By doing that, we can avoid data duplication. Additionally, I have created indexes for properties that can be used as criteria for searching. This can shorten the time needed for querying specific documents.

{% hint style="info" %}
If you have not set up your local development environment for automated tests yet, [click here](../../test-driven-development-tdd.md#set-things-up) for how to do it.
{% endhint %}

It's time to create our first test script for the most basic test case on the server side, _"the server endpoint for getting survey data must return an empty array if there are some surveys in the database but no survey is active"_, in the list of test cases we created in [step 4](4.-write-test-cases.md).

<details>

<summary>[pfserver] src/__<strong>tests__</strong>/routers/api/survey.test.ts</summary>

```typescript
import 'dotenv/config'
import request from 'supertest'
import mongoose from 'mongoose'
import { PageFlyServer } from '../../../server'
import SurveyModel from '../../../data/models/Survey'
import PageFlyShopifyHandler from '../../../handlers/shopify'

describe('Test the server endpoint /api/survey', () => {
  let server, handler, agent

  beforeAll(async () => {
    // Connect Mongoose to MongoDB.
    await mongoose.connect(process.env.MONGODB_URI_FOR_AUTOMATED_TESTS, { keepAlive: true })

    // Fake some environment variables.
    process.env.CATALOG_DATA_IMPORTED = 'yes'

    // Init PageFly server.
    server = new PageFlyServer()
    handler = new PageFlyShopifyHandler(server.app, null)

    handler.initRouting()

    // Init an agent for testing.
    agent = request.agent(server.app)

    // Clear mock data.
    await SurveyModel.deleteMany({})
  })

  afterAll(async () => {
    // Clear mock data.
    await SurveyModel.deleteMany({})

    // Disconnect from MongoDB.
    await mongoose.connection.close()
  })

  it('should return an empty array if there are some surveys in the database but no survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 1',
        questions: [
          {
            type: 'text',
            question: 'How are you today?'
          }
        ],
        status: 'inactive'
      },
      {
        title: 'Survey 2',
        questions: [
          {
            type: 'text',
            question: 'How can I help you today?'
          }
        ],
        status: 'inactive'
      },
    ])

    // Send a GET request to the API endpoint.
    const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(0)
  })
})
```

</details>

If you have not started an automated test session yet, run the following command in the terminal to start one.

```sh
yarn cross-env NODE_ENV=test jest survey.test.ts --watchAll --detectOpenHandles
```

You will see the following text printed on the terminal.

```
 FAIL  src/__tests__/routers/api/survey.test.ts (5.396 s)
  Test the server endpoint /api/survey
    ✕ should return an empty array if there are some surveys in the database but no survey is active (302 ms)

  ● Test the server endpoint /api/survey › should return an empty array if there are some surveys in the database but no survey is active

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: undefined

      62 |     const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')
      63 |
    > 64 |     expect(res.body.success).toBe(1)
         |                              ^
      65 |     expect(res.body.surveys.length).toBe(0)
      66 |   })
      67 | })

      at Object.<anonymous> (src/__tests__/routers/api/survey.test.ts:64:30)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        5.44 s
Ran all test suites matching /survey.test.ts/i.

Active Filters: filename /survey.test.ts/
 › Press c to clear filters.

Watch Usage
 › Press f to run only failed tests.
 › Press o to only run tests related to changed files.
 › Press q to quit watch mode.
 › Press i to run failing tests interactively.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press Enter to trigger a test run.
```

The automated test session is ready now, let's create a server endpoint for getting survey data to pass the first test case and then refactor it to standards.

<details>

<summary>[pfserver] src/routers/api/survey.ts</summary>

```typescript
import ShopModel from '../../data/models/Shop'
import SurveyModel from '../../data/models/Survey'
import {NextFunction, Request, Response} from 'express'

export async function handleGet(req: Request, res: Response, next?: NextFunction) {
  try {
    // Define query for getting active surveys.
    const query = { status: 'active' }

    // Query for active surveys.
    const surveys = await SurveyModel.find(query, '_id title description questions')

    res.status(200).json({success: 1, surveys})
  } catch (e) {
    res.status(500).json({success: 0, message: e.message || e})
  }
}
```

</details>

Switch to the terminal where you started the automated test session, you will see the following test result.

```
 PASS  src/__tests__/routers/api/survey.test.ts
  Test the server endpoint /api/survey
    ✓ should return an empty array if there are some surveys in the database but no survey is active (699 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        2.26 s
Ran all test suites matching /survey.test.ts/i.

Watch Usage: Press w to show more.
```

Now, continue to write another test script for the second test case related to the `pfserver` project: _The server endpoint for getting survey data must return only the active survey as a single item array if there are some surveys in the database but only one survey is active_.

<details>

<summary>[pfserver] src/__<strong>tests__</strong>/routers/api/survey.test.ts</summary>

```typescript
import 'dotenv/config'
import request from 'supertest'
import mongoose from 'mongoose'
import { PageFlyServer } from '../../../server'
import ShopModel from '../../../data/models/Shop'
import SurveyModel from '../../../data/models/Survey'
import PageFlyShopifyHandler from '../../../handlers/shopify'

describe('Test the server endpoint /api/survey', () => {
  let server, handler, agent

  beforeAll(async () => {
    // Connect Mongoose to MongoDB.
    await mongoose.connect(process.env.MONGODB_URI_FOR_AUTOMATED_TESTS, { keepAlive: true })

    // Fake some environment variables.
    process.env.CATALOG_DATA_IMPORTED = 'yes'

    // Init PageFly server.
    server = new PageFlyServer()
    handler = new PageFlyShopifyHandler(server.app, null)

    handler.initRouting()

    // Init an agent for testing.
    agent = request.agent(server.app)

    // Clear mock data.
    await SurveyModel.deleteMany({})
  })

  afterAll(async () => {
    // Clear mock data.
    await SurveyModel.deleteMany({})

    // Disconnect from MongoDB.
    await mongoose.connection.close()
  })

  it('should return an empty array if there are some surveys in the database but no survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 1',
        questions: [
          {
            type: 'text',
            question: 'How are you today?'
          }
        ],
        status: 'inactive'
      },
      {
        title: 'Survey 2',
        questions: [
          {
            type: 'text',
            question: 'How can I help you today?'
          }
        ],
        status: 'inactive'
      },
    ])

    // Send a GET request to the API endpoint.
    const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(0)
  })

  it('should return only the active survey as a single item array if there are some surveys in the database but only one survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 3',
        questions: [
          {
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active'
      },
    ])

    // Send a GET request to the API endpoint.
    let res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in a specified time range.
    await SurveyModel.insertMany([
      {
        title: 'Survey 3',
        questions: [
          {
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active',
        endTime: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 4',
        questions: [
          {
            type: 'text',
            question: 'What is your opinion for Black Friday campaign?'
          }
        ],
        status: 'active',
        includeLocations: ['US'],
      },
    ])

    await ShopModel.updateOne(
      { shopDomain: 'cuongnm-dev-store.myshopify.com' },
      { metadata: { country_code: 'VN' } },
      { upsert: true }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active all locations except specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 4',
        questions: [
          {
            type: 'text',
            question: 'What is your plan for Christmas Eve?'
          }
        ],
        status: 'active',
        excludeLocations: ['VN'],
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)
  })
})
```

</details>

Again, the new test fails and we need to update the server endpoint for getting survey data as follows to pass the test.

<details>

<summary>[pfserver] src/routers/api/survey.ts</summary>

```typescript
import ShopModel from '../../data/models/Shop'
import SurveyModel from '../../data/models/Survey'
import {NextFunction, Request, Response} from 'express'

export async function handleGet(req: Request, res: Response, next?: NextFunction) {
  try {
    // Get current time.
    const now = new Date()

    // Get the current shop location.
    const {shop: shopDomain} = req.session
    const shopData = await ShopModel.findOne({shopDomain})
    const shopLocation = shopData?.metadata?.country_code

    // Define query for getting active surveys.
    const query = {
      $and: [
        // Has active status.
        {status: 'active'},
        // Has start time undefined or earlier than the current time.
        {
          $or: [
            { startTime: null },
            { startTime: { $exists: false } },
            { startTime: { $lt: now } },
          ],
        },
        // Has end time undefined or later than the current time.
        {
          $or: [
            { endTime: null },
            { endTime: { $exists: false } },
            { endTime: { $gt: now } },
          ],
        },
        // Has included location undefined or includes the shop location.
        {
          $or: [
            { includeLocations: null },
            { includeLocations: { $exists: false } },
            { includeLocations: { $size: 0 } },
            { includeLocations: shopLocation },
          ],
        },
        // Has excluded location undefined or not includes the shop location.
        {
          $or: [
            { excludeLocations: null },
            { excludeLocations: { $exists: false } },
            { excludeLocations: { $size: 0 } },
            { excludeLocations: { $nin: [shopLocation] } },
          ],
        },
      ],
    }

    // Query for active surveys.
    const surveys = await SurveyModel.find(query, '_id title description questions')

    res.status(200).json({success: 1, surveys})
  } catch (e) {
    res.status(500).json({success: 0, message: e.message || e})
  }
}
```

</details>

You need to repeat the test-driven development cycle we've done above for the remaining test cases related to the `pfserver` project until all test cases are covered. Below is the final version of the test script file and the source code file I created for this example.

<details>

<summary>[pfserver] src/<strong>tests</strong>/routers/api/survey.test.ts</summary>

```typescript
import 'dotenv/config'
import request from 'supertest'
import mongoose from 'mongoose'
import { PageFlyServer } from '../../../server'
import ShopModel from '../../../data/models/Shop'
import SurveyModel from '../../../data/models/Survey'
import PageFlyShopifyHandler from '../../../handlers/shopify'
import SurveyResponseModel from '../../../data/models/SurveyResponse'

describe('Test the server endpoint /api/survey', () => {
  let server, handler, agent

  beforeAll(async () => {
    // Connect Mongoose to MongoDB.
    await mongoose.connect(process.env.MONGODB_URI_FOR_AUTOMATED_TESTS, { keepAlive: true })

    // Fake some environment variables.
    process.env.CATALOG_DATA_IMPORTED = 'yes'

    // Init PageFly server.
    server = new PageFlyServer()
    handler = new PageFlyShopifyHandler(server.app, null)

    handler.initRouting()

    // Init an agent for testing.
    agent = request.agent(server.app)

    // Clear mock data.
    await SurveyModel.deleteMany({})
  })

  afterAll(async () => {
    // Clear mock data.
    await SurveyModel.deleteMany({})

    // Disconnect from MongoDB.
    await mongoose.connection.close()
  })

  it('should return an empty array if there are some surveys in the database but no survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 1',
        questions: [
          {
            _id: new mongoose.Types.ObjectId(),
            type: 'text',
            question: 'How are you today?'
          }
        ],
        status: 'inactive'
      },
      {
        title: 'Survey 2',
        questions: [
          {
            _id: new mongoose.Types.ObjectId(),
            type: 'text',
            question: 'How can I help you today?'
          }
        ],
        status: 'inactive'
      },
    ])

    // Send a GET request to the API endpoint.
    const res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(0)
  })

  it('should return only the active survey as a single item array if there are some surveys in the database but only one survey is active', async () => {
    // Create mock data.
    await SurveyModel.insertMany([
      {
        title: 'Survey 3',
        questions: [
          {
            _id: new mongoose.Types.ObjectId(),
            type: 'text',
            question: 'What do you want me to do?'
          }
        ],
        status: 'active'
      },
    ])

    // Send a GET request to the API endpoint.
    let res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in a specified time range.
    await SurveyModel.insertMany([
      {
        title: 'Survey 4',
        questions: [
          {
            _id: new mongoose.Types.ObjectId(),
            type: 'text',
            question: 'What do you think about what I have done?'
          }
        ],
        status: 'active',
        endTime: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 5',
        questions: [
          {
            _id: new mongoose.Types.ObjectId(),
            type: 'text',
            question: 'What is your opinion for Black Friday campaign?'
          }
        ],
        status: 'active',
        includeLocations: ['US'],
      },
    ])

    await ShopModel.updateOne(
      { shopDomain: 'cuongnm-dev-store.myshopify.com' },
      { metadata: { country_code: 'VN' } },
      { upsert: true }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)

    // Create mock data to test survey active in all locations except specified locations.
    await SurveyModel.insertMany([
      {
        title: 'Survey 6',
        questions: [
          {
            _id: new mongoose.Types.ObjectId(),
            type: 'text',
            question: 'What is your plan for Christmas Eve?'
          }
        ],
        status: 'active',
        excludeLocations: ['VN'],
      },
    ])

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(1)
  })

  it('should return all the active surveys as an array if there are several active surveys in the database', async () => {
    // Update mock data to test survey active in a specified time range..
    await SurveyModel.updateOne(
      { title: 'Survey 4' },
      {
        startTime: new Date(Date.now() - 24 * 60 * 60 * 1000),
        endTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
      }
    )

    // Send a GET request to the API endpoint.
    let res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(2)

    // Update mock data to test survey active in specified locations.
    await SurveyModel.updateOne(
      { title: 'Survey 5' },
      { includeLocations: ['VN'] }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(3)

    // Update mock data to test survey active in all locations except specified locations.
    await SurveyModel.updateOne(
      { title: 'Survey 6' },
      { excludeLocations: ['US'] }
    )

    // Send a GET request to the API endpoint.
    res = await agent.get('/api/survey?shop=cuongnm-dev-store.myshopify.com')

    expect(res.body.success).toBe(1)
    expect(res.body.surveys.length).toBe(4)
  })

  it('should return an error message if no user response or invalid data is posted to it', async () => {
    // Send a POST request to the API endpoint.
    let res = await agent
      .post('/api/survey?shop=cuongnm-dev-store.myshopify.com')
      .send({})

    expect(res.body.success).toBe(0)
    expect(res.body.message).toBe('Missing data!')

    // Update mock data for test saving user responses.
    const survey_3 = await SurveyModel.findOne({ title: 'Survey 3' })

    // Emulate a user response.
    const response = {
      [survey_3._id.toString()]: {}
    }

    // Send a POST request to the API endpoint.
    res = await agent
      .post('/api/survey?shop=cuongnm-dev-store.myshopify.com')
      .send({ data: response })

    expect(res.body.success).toBe(0)
    expect(res.body.message).toBe('Invalid data!')
  })

  it('should save data and return a success message if a valid user response is posted to it', async () => {
    // Get mock data for test saving user responses.
    const survey_3 = await SurveyModel.findOne({ title: 'Survey 3' })

    // Emulate a user response.
    const response = {
      [survey_3._id.toString()]: {
        answers: {
          [survey_3.questions[0]._id.toString()]: {
            textAnswer: 'Create a page for me'
          }
        }
      }
    }

    // Send a POST request to the API endpoint.
    let res = await agent
      .post('/api/survey?shop=cuongnm-dev-store.myshopify.com')
      .send({ data: response })

    expect(res.body.success).toBe(1)

    // Query for the user response just saved.
    res = await SurveyResponseModel.findOne({ surveyId: survey_3._id, shopDomain: 'cuongnm-dev-store.myshopify.com' })

    expect(res.responses[0].textAnswer).toBe('Create a page for me')
  })

  it('should save all data and return a success message if multiple valid user responses are posted to it', async () => {
    // Get mock data for test saving user responses.
    const survey_3 = await SurveyModel.findOne({ title: 'Survey 3' })
    const survey_4 = await SurveyModel.findOne({ title: 'Survey 4' })

    // Emulate a user response.
    const response = {
      [survey_3._id.toString()]: {
        answers: {
          [survey_3.questions[0]._id.toString()]: {
            textAnswer: 'Create a page for me'
          }
        }
      },
      [survey_4._id.toString()]: {
        answers: {
          [survey_4.questions[0]._id.toString()]: {
            textAnswer: 'It looks good'
          }
        }
      }
    }

    // Send a POST request to the API endpoint.
    let res = await agent
      .post('/api/survey?shop=cuongnm-dev-store.myshopify.com')
      .send({ data: response })

    expect(res.body.success).toBe(1)

    // Query for the user responses just saved.
    res = await SurveyResponseModel.findOne({ surveyId: survey_3._id, shopDomain: 'cuongnm-dev-store.myshopify.com' })

    expect(res.responses[0].textAnswer).toBe('Create a page for me')

    res = await SurveyResponseModel.findOne({ surveyId: survey_4._id, shopDomain: 'cuongnm-dev-store.myshopify.com' })

    expect(res.responses[0].textAnswer).toBe('It looks good')
  })
})
```

</details>

<details>

<summary>[pfserver] src/routers/api/survey.ts</summary>

```typescript
import ShopModel from '../../data/models/Shop'
import SurveyModel from '../../data/models/Survey'
import {NextFunction, Request, Response} from 'express'
import SurveyResponseModel, { SurveyResponseType } from '../../data/models/SurveyResponse'

export async function handleGet(req: Request, res: Response, next?: NextFunction) {
  try {
    // Get current time.
    const now = new Date()

    // Get the current shop location.
    const {shop: shopDomain} = req.session
    const shopData = await ShopModel.findOne({shopDomain})
    const shopLocation = shopData?.metadata?.country_code

    // Define query for getting active surveys.
    const query = {
      $and: [
        // Has active status.
        {status: 'active'},
        // Has start time undefined or earlier than the current time.
        {
          $or: [
            { startTime: null },
            { startTime: { $exists: false } },
            { startTime: { $lt: now } },
          ],
        },
        // Has end time undefined or later than the current time.
        {
          $or: [
            { endTime: null },
            { endTime: { $exists: false } },
            { endTime: { $gt: now } },
          ],
        },
        // Has included location undefined or includes the shop location.
        {
          $or: [
            { includeLocations: null },
            { includeLocations: { $exists: false } },
            { includeLocations: { $size: 0 } },
            { includeLocations: shopLocation },
          ],
        },
        // Has excluded location undefined or not includes the shop location.
        {
          $or: [
            { excludeLocations: null },
            { excludeLocations: { $exists: false } },
            { excludeLocations: { $size: 0 } },
            { excludeLocations: { $nin: [shopLocation] } },
          ],
        },
      ],
    }

    // Query for active surveys.
    const surveys = await SurveyModel.find(query, '_id title description questions')

    res.status(200).json({success: 1, surveys})
  } catch (e) {
    res.status(500).json({success: 0, message: e.message || e})
  }
}

export async function handlePost(req: Request, res: Response, next?: NextFunction) {
  try {
    // Get current shop.
    const { shop: shopDomain } = req.session

    // Get user response from POST body.
    const { data } = req.body

    if (!data) {
      throw new Error('Missing data!')
    }

    // Prepare posted data.
    const responses: SurveyResponseType[] = []

    for (const surveyId in data) {
      if (data[surveyId].answers) {
        const answer: SurveyResponseType = { surveyId, shopDomain, responses: [] }

        for (const questionId in data[surveyId].answers) {
          answer.responses.push({ questionId, ...data[surveyId].answers[questionId] })
        }

        responses.push(answer)
      }
    }

    if (!responses.length) {
      throw new Error('Invalid data!')
    }

    // Insert user responses to the database.
    SurveyResponseModel.bulkWrite(responses.map(response => {
      const { surveyId, shopDomain, ...rest } = response

      return {
        updateOne: {
          filter: { surveyId, shopDomain },
          update: rest,
          upsert: true,
        }
      }
    }))

    return res.status(200).json({ success: 1 })
  } catch (e) {
    res.status(500).json({ success: 0, message: e.message || e })
  }
}
```

</details>

That's enough for the server side. It's time to write tests and code for the client side.

Because stakeholders might want to display the survey in multiple places, We will create storage to save the survey content instead of storing it in the component state. The storage below extends the base storage class I created in [this proposal](../../refactor-pagefly-applying-oop/apply-the-oop-concept-to-refactor-pagefly/storage-mechanism.md).

If you want, you can create storage the way you like. But, make sure that every component needs to access and mutate the data via predefined methods bound to the data instead of the direct way via object properties. This behavior ensures the safety of the data.

Storage is only used to store the result returned when requesting the server endpoint for getting survey data so testing it is unnecessary.

<details>

<summary>[pfcore] src/next/modules/survey/constant.ts</summary>

```typescript
export const SURVEY_API_ENDPOINT = '/api/survey'
```

</details>

<details>

<summary>[pfcore] src/next/modules/survey/storage.ts</summary>

```typescript
import Storage from '@/@refactoring/includes/storage'
import { SURVEY_API_ENDPOINT } from '@/modules/survey/constant'

export type SurveyDataType = {
  surveys: {
    _id: string
    title: string
    description: string
    questions: [{
      _id: string
      type: 'text' | 'radio' | 'checkbox'
      question: string
      // Predefined answers are only required if the `type` is not 'text'.
      answers?: [{
        _id: string
        answer: string
      }]
    }]
  }[]
}

/**
 * Define storage for storing survey data.
 */
export default class SurveyStorage extends Storage<SurveyDataType, SurveyDataType> {
  // Define API endpoints for requesting data.
  static syncWithServerURL = SURVEY_API_ENDPOINT
}
```

</details>

Everything is ready now. Let's create the first test script for the most basic test case related to the `pfcore` project: _No modal should be opened if there is no active survey_.

<details>

<summary>[pfcore] src/next/<strong>tests</strong>/modules/survey.test.tsx</summary>

```typescript
import Survey from '@/modules/survey'
import SurveyStorage from '@/modules/survey/storage'
import { mountWithApp } from '@test/utilities/react-testing'
import { cleanup, fireEvent, screen, waitFor } from '@testing-library/react'

describe('Test survey module', () => {
  beforeEach(() => {
    cleanup()
    jest.clearAllMocks()
  })

  afterEach(() => {
    cleanup()
    jest.clearAllMocks()
  })

  it('should not open any modal if there is no active survey', async () => {
    // Mount the survey component.
    const component = mountWithApp(<Survey />)

    component.act(
      () => {
        // Emulate survey data.
        SurveyStorage.getInstance().update({ surveys: [] })

        // Force component update.
        component.forceUpdate()
      },
      { update: true }
    )

    await waitFor(() => {
      expect(screen.getByTestId('pf-no-survey-placeholder')).toBeInTheDocument()
    })
  })
})
```

</details>

If you have not started an automated test session yet, open the terminal and run the following command to start one.

```sh
yarn test survey.test.tsx
```

The following text should be printed in the terminal where you started the automated test session.

```
 FAIL  src/next/__tests__/modules/survey.test.tsx
  ● Test suite failed to run

    Configuration error:
    
    Could not locate module @/modules/survey mapped as:
    /Users/cuongnguyen/Documents/Workspace/PageFly/App/Core/src/next/$1.
    
    Please check your configuration for these entries:
    {
      "moduleNameMapper": {
        "/@\/(.*)$/": "/Users/cuongnguyen/Documents/Workspace/PageFly/App/Core/src/next/$1"
      },
      "resolver": undefined
    }

    > 1 | import Survey from '@/modules/survey'
        | ^
      2 | import { Modal } from '@shopify/polaris'
      3 | import { cleanup } from '@testing-library/react'
      4 | import SurveyStorage from '@/modules/survey/storage'

      at createNoMappedModuleFoundError (node_modules/jest-runtime/node_modules/jest-resolve/build/resolver.js:759:17)
      at Object.require (src/next/__tests__/modules/survey.test.tsx:1:1)

Test Suites: 1 failed, 1 total
Tests:       0 total
Snapshots:   0 total
Time:        0.543 s, estimated 2 s
Ran all test suites matching /survey.test.tsx/i.

Watch Usage: Press w to show more.
```

We need to create a stand-alone UI component to display active surveys, ensure it passes the test, and then refactor it to standards. Again, I will extend the base component class I created in [this proposal](../../refactor-pagefly-applying-oop/apply-the-oop-concept-to-refactor-pagefly/refactor-ui-components.md).

If you want, you can create UI components the way you like. But, make sure that the UI component does not rely on other functionalities to work as intended. It also must not affect other functionalities of the app.

After creating a stand-alone UI component to pass the first test, repeat the process till all test cases related to the `pfcore` project are covered. Below is the final version of the test script file and the source code file I created for this example.

<details>

<summary>[pfcore] src/next/<strong>tests</strong>/modules/survey.test.tsx</summary>

```typescript
import Survey from '@/modules/survey'
import SurveyStorage from '@/modules/survey/storage'
import { mountWithApp } from '@test/utilities/react-testing'
import { cleanup, fireEvent, screen, waitFor } from '@testing-library/react'

describe('Test survey module', () => {
  beforeEach(() => {
    cleanup()
    jest.clearAllMocks()
  })

  afterEach(() => {
    cleanup()
    jest.clearAllMocks()
  })

  it('should not open any modal if there is no active survey', async () => {
    // Mount the survey component.
    const component = mountWithApp(<Survey />)

    component.act(
      () => {
        // Emulate survey data.
        SurveyStorage.getInstance().update({ surveys: [] })

        // Force component update.
        component.forceUpdate()
      },
      { update: true }
    )

    await waitFor(() => {
      expect(screen.getByTestId('pf-no-survey-placeholder')).toBeInTheDocument()
    })
  })

  it('should open a modal containing one survey if there is an active survey', async () => {
    // Mount the survey component.
    const component = mountWithApp(<Survey />)

    component.act(
      () => {
        // Emulate survey data.
        SurveyStorage.getInstance().update({
          surveys: [{
            _id: 'survey-1',
            title: 'Survey 1',
            description: 'Description for survey 1',
            questions: [
              {
                _id: 'question-1',
                type: 'text',
                question: 'How are you today?'
              }
            ]
          }]
        })

        // Force component update.
        component.forceUpdate()
      },
      { update: true }
    )

    await waitFor(() => {
      expect(screen.getByTestId('pf-survey-container')).toBeInTheDocument()
      expect(screen.getByText('Survey 1')).toBeInTheDocument()
      expect(screen.getByText('Description for survey 1')).toBeInTheDocument()
      expect(screen.getByText('How are you today?')).toBeInTheDocument()
    })
  })

  it('should open a modal with pagination to navigate between multiple surveys if there is more than one active survey', async () => {
    // Mount the survey component.
    const component = mountWithApp(<Survey />)

    component.act(
      () => {
        // Emulate survey data.
        SurveyStorage.getInstance().set('surveys', [
          {
            _id: 'survey-1',
            title: 'Survey 1',
            description: 'Description for survey 1',
            questions: [
              {
                _id: 'question-1',
                type: 'text',
                question: 'How are you today?'
              }
            ]
          },
          {
            _id: 'survey-2',
            title: 'Survey 2',
            description: 'Description for survey 2',
            questions: [
              {
                _id: 'question-2',
                type: 'text',
                question: 'What do you want me to do?'
              }
            ]
          }
        ])

        // Force component update.
        component.forceUpdate()
      },
      { update: true }
    )

    await waitFor(async () => {
      expect(screen.getByTestId('pf-survey-container')).toBeInTheDocument()
      expect(screen.getByText('<')).toBeInTheDocument()
      expect(screen.getByText('>')).toBeInTheDocument()

      component.act(
        () => {
          // Emulate a click event on the button to jump to next survey.
          fireEvent.click(screen.getByText('>'))

          // Force component update.
          component.forceUpdate()
        },
        { update: true }
      )

      await waitFor(async () => {
        expect(screen.getByText('Survey 2')).toBeInTheDocument()
        expect(screen.getByText('Description for survey 2')).toBeInTheDocument()
        expect(screen.getByText('What do you want me to do?')).toBeInTheDocument()

        component.act(
          () => {
            // Emulate a click event on the button to jump to previous survey.
            fireEvent.click(screen.getByText('<'))

            // Force component update.
            component.forceUpdate()
          },
          { update: true }
        )

        await waitFor(() => {
          expect(screen.getByText('Survey 1')).toBeInTheDocument()
          expect(screen.getByText('Description for survey 1')).toBeInTheDocument()
          expect(screen.getByText('How are you today?')).toBeInTheDocument()
        })
      })
    })
  })
})
```

</details>

<details>

<summary>[pfcore] src/next/modules/survey/index.tsx</summary>

```typescript
import Component, { StringMapping } from '@/@refactoring/includes/component'
import SurveyStorage, { SurveyDataType } from '@/modules/survey/storage'
import { t } from 'i18next'
import { debounce } from 'lodash'
import { ReactNode } from 'react'
import { Modal } from '@shopify/polaris'
import { SURVEY_API_ENDPOINT } from '@/modules/survey/constant'
import { fetchWithSessionToken } from '@/views/embed/session-token-helper'

type SurveyPropsType = {
  visible?: boolean
  activator?: ReactNode
}

type SurveyStateType = SurveyDataType & {
  visible: boolean
  currentSurveyIndex: number
}

type UserResponseType = {
  [surveyId: string]: {
    answers: {
      [questionId: string]: {
        // Answer ID is only available if the question `type` is not 'text'.
        answerId?: string[]
        // Text answer is only available if the question `type` is 'text'.
        textAnswer?: string
      }
    }
  }
}

export default class Survey extends Component<SurveyPropsType, SurveyStateType> {
  // Define storage to populate component state from in `defaultProps`.
  static defaultProps = {
    storages: [SurveyStorage],
  }

  // Define mapping from storage data to component state.
  static storageToState: StringMapping = { 'SurveyStorage.surveys': 'surveys' }

  // Define initial component state.
  state: SurveyStateType = { surveys: [], visible: true, currentSurveyIndex: 0 }

  // Define a variable to hold user responses.
  responses: UserResponseType = {}

  constructor(props) {
    super(props)

    // Populate initial state.
    if (props.visible !== undefined) {
      this.state.visible = props.visible
    }
  }

  /**
   * Method to close the survey modal.
   */
  closeModal = () => this.setState({ visible: false })

  /**
   * Method to POST user responses to server.
   */
  saveUserResponses = () => {
    // Send user responses to server.
    if (Object.keys(this.responses).length) {
      fetchWithSessionToken(SURVEY_API_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ data: this.responses }),
      }).catch(console.error)
    }

    // Close the survey modal.
    this.closeModal()
  }

  /**
   * Method to handle changes in form fields.
   */
  handleChange = debounce(e => {
    const { surveys, currentSurveyIndex } = this.state

    // Update user responses.
    const surveyId = surveys[currentSurveyIndex]._id
    const questionId = e.target.name

    if (!this.responses[surveyId]) {
      this.responses[surveyId] = { answers: {} }
    }

    if (e.target.type === 'text') {
      this.responses[surveyId].answers[questionId] = { textAnswer: e.target.value }
    } else {
      if (!this.responses[surveyId].answers[questionId]) {
        this.responses[surveyId].answers[questionId] = { answerId: [] }
      }

      if (e.target.type === 'radio') {
        this.responses[surveyId].answers[questionId].answerId = [e.target.value]
      } else {
        // Handle checkboxes.
        if (e.target.checked) {
          if (!this.responses[surveyId].answers[questionId].answerId.includes(e.target.value)) {
            this.responses[surveyId].answers[questionId].answerId.push(e.target.value)
          }
        } else {
          const index = this.responses[surveyId].answers[questionId].answerId.indexOf(e.target.value)

          if (index > -1) {
            this.responses[surveyId].answers[questionId].answerId.splice(index, 1)
          }
        }
      }
    }
  }, 200)

  render(): ReactNode {
    const { activator } = this.props
    const { surveys, visible, currentSurveyIndex } = this.state

    if (!surveys?.length || (!visible && !activator)) {
      return <div data-testid="pf-no-survey-placeholder"></div>
    }

    const currentSurvey = surveys[currentSurveyIndex]

    return (
      <div data-testid="pf-survey-container">
        {activator && (
          <a href="#survey" onClick={() => this.setState({ visible: !visible })}>
            {activator}
          </a>
        )}
        <Modal
          open={visible}
          onClose={this.closeModal}
          title={currentSurvey.title}
          primaryAction={{
            content: t('SAVE'),
            onAction: this.saveUserResponses,
          }}
          secondaryActions={[
            ...(surveys.length > 1
              ? [
                  {
                    content: '<',
                    disabled: currentSurveyIndex === 0,
                    onAction: () => this.setState({ currentSurveyIndex: currentSurveyIndex - 1 }),
                  },
                  {
                    content: '>',
                    disabled: currentSurveyIndex === surveys.length - 1,
                    onAction: () => this.setState({ currentSurveyIndex: currentSurveyIndex + 1 }),
                  },
                ]
              : []),
            {
              content: t('CANCEL'),
              onAction: this.closeModal,
            },
          ]}
        >
          <form onSubmit={e => e.preventDefault()}>
            {currentSurvey.description && <legend>{currentSurvey.description}</legend>}
            {currentSurvey.questions.map(question => {
              const response = this.responses[currentSurvey._id]?.answers?.[question._id]

              return (
                <div key={question._id}>
                  <label>{question.question}</label>
                  {question.type === 'text' ? (
                    <input
                      type="text"
                      name={question._id}
                      onChange={this.handleChange}
                      defaultValue={response?.textAnswer}
                    />
                  ) : (
                    question.answers.map(answer => (
                      <div>
                        <input
                          value={answer._id}
                          name={question._id}
                          type={question.type}
                          onChange={this.handleChange}
                          defaultChecked={response?.answerId?.includes(answer._id)}
                        />
                        <span>{answer.answer}</span>
                      </div>
                    ))
                  )}
                </div>
              )
            })}
          </form>
        </Modal>
      </div>
    )
  }
}
```

</details>

Now, we have a module dedicated to displaying surveys and collecting user responses. If stakeholders want the survey to show automatically on certain screens, you can place the JSX tag `<Survey />` at the appropriate positions in the code base. On the other hand, if stakeholders want to show a link somewhere that when clicking on will open the survey, you can use the JSX tag `<Survey visible={false} activator="Open survey" />`.

Last but not least, we need to create a screen in AC2 to display user responses to stakeholders and another screen to allow stakeholders to update or remove surveys or create a new survey.

|                            Current step                           |
| :---------------------------------------------------------------: |
| [5.-test-and-code.md](../processes/5.-test-and-code.md "mention") |
