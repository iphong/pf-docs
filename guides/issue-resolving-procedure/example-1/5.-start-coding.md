---
description: >-
  Display a survey to PageFly users to collect their needs for the Black Friday
  campaign.
---

# 5. Start coding

Suppose that the time-to-market of the request to _“display a survey to PageFly users to collect their needs for the Black Friday campaign”_ is not too close, which allows having enough time to implement the simplest and most effective solution ([the third solution](./#id-3.3.-evaluate-the-third-solution)).

First, we will declare schemas for two collections, one for saving surveys and the other for saving user responses. Because we have to pay the MongoDB cloud service for the amount of stored data, let's make the data structure as lean as possible by keeping the relationship between documents and collections straightforward and avoiding data duplication.

<details>

<summary>[pfserver] src/data/models/Survey.ts</summary>

```typescript
import mongoose, { Document } from 'mongoose'

// Define document type.
export type SurveyType = Document & {
  _id: string
  title: string
  description?: string
  questions: [{
    _id: string
    type: 'text' | 'radio' | 'checkbox'
    question: string
    // Predefined answers are only required if the `type` is not 'text'.
    answers?: [{
      _id: string
      answer: string
    }]
  }]
  status: 'active' | 'inactive'
  // If both `startTime` and `endTime` are undefined, the survey will
  // always be visible until its `status` is set to 'inactive'.
  startTime?: Date
  endTime?: Date
  // If `includeLocations` is undefined, the survey will be visible in
  // all locations except locations defined for `excludeLocations`.
  includeLocations?: string[]
  // If `excludeLocations` is defined, the survey will be invisible in
  // all locations defined for `excludeLocations`.
  excludeLocations?: string[]
}

// Define model schema.
const surveySchema = new mongoose.Schema(
  {
    _id: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      index: true,
    },
    title: {
      type: String,
      required: true,
      index: true,
    },
    description: String,
    questions: [{
      _id: {
        type: mongoose.Schema.Types.ObjectId,
        required: true,
        index: true,
      },
      type: {
        type: String,
        enum: ['text', 'radio', 'checkbox'],
        required: true,
        index: true,
      },
      question: {
        type: String,
        required: true,
        index: true,
      },
      // Predefined answers are only required if the `type` is not 'text'.
      answers: [{
        _id: {
          type: mongoose.Schema.Types.ObjectId,
          required: true,
          index: true,
        },
        answer: {
          type: String,
          required: true,
          index: true,
        },
      }],
    }],
    status: {
      type: String,
      enum: ['active', 'inactive'],
      default: 'inactive',
      index: true,
    },
    // If both `startTime` and `endTime` are undefined, the survey will
    // always be visible until its `status` is set to 'inactive'.
    startTime: {
      type: Date,
      index: true,
    },
    endTime: {
      type: Date,
      index: true,
    },
    // If `includeLocations` is undefined, the survey will be visible in
    // all locations except locations defined for `excludeLocations`.
    includeLocations: [{
      type: String,
      index: true,
    }],
    // If `excludeLocations` is defined, the survey will be invisible in
    // all locations defined for `excludeLocations`.
    excludeLocations: [{
      type: String,
      index: true,
    }],
  },
  { timestamps: true }
)

const SurveyModel = mongoose.model<SurveyType>('Survey', surveySchema)

export default SurveyModel
```

</details>

<details>

<summary>[pfserver] src/data/models/SurveyResponse.ts</summary>

```typescript
import mongoose, {Document} from 'mongoose'

// Define document type.
export type SurveyResponseType = Document & {
  _id: string
  surveyId: string
  shopDomain: string
  answers: [{
    questionId: string
    // Answer ID is only available if the question `type` is not 'text'.
    answerId?: string[]
    // Text answer is only available if the question `type` is 'text'.
    textAnswer?: string
  }]
}

// Define model schema.
const surveyResponseSchema = new mongoose.Schema(
  {
    _id: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      index: true,
    },
    surveyId: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      index: true,
      ref: 'Survey',
    },
    shopDomain: {
      type: String,
      required: true,
      index: true,
      ref: 'Shop',
    },
    answers: [{
      questionId: {
        type: mongoose.Schema.Types.ObjectId,
        required: true,
        index: true,
      },
      // Answer ID is only available if the question `type` is not 'text'.
      answerId: [{
        type: mongoose.Schema.Types.ObjectId,
        required: true,
        index: true,
      }],
      // Text answer is only available if the question `type` is 'text'.
      textAnswer: String,
    }],
  },
  { timestamps: true }
)

const SurveyResponseModel = mongoose.model<SurveyResponseType>('SurveyResponse', surveyResponseSchema)

export default SurveyResponseModel
```

</details>

As you can see, the `SurveyResponse` model does not save any data saved in the `Survey` model except for ID-related properties. By doing that, we can avoid data duplication. Additionally, I have created indexes for properties that can be used as criteria for searching. This can shorten the time needed for querying specific documents.

After having data models, we will create the necessary endpoints for getting active surveys and saving user responses.

<details>

<summary>[pfserver] src/routers/api/survey.ts</summary>

```typescript
import ShopModel from 'data/models/Shop'
import SurveyModel from 'data/models/Survey'
import SurveyResponseModel from 'data/models/SurveyResponse'
import { NextFunction, Request, Response } from 'express'

export async function handleGet(req: Request, res: Response, next?: NextFunction) {
  try {
    // Get current time.
    const now = new Date()

    // Get current shop location.
    const { shop: shopDomain } = req.session
    const shopData = await ShopModel.findOne({ shopDomain })
    const shopLocation = shopData?.metadata?.country_code

    // Define query for getting active surveys.
    const query = {
      $and: [
        // Has active status.
        { status: 'active' },
        // Has start time undefined or earlier than the current time.
        {
          $or: [
            { startTime: null },
            { startTime: { $exists: false } },
            { startTime: { $lt: now } },
          ]
        },
        // Has end time undefined or later than the current time.
        {
          $or: [
            { endTime: null },
            { endTime: { $exists: false } },
            { endTime: { $gt: now } },
          ]
        },
        // Has included location undefined or includes the shop location.
        {
          $or: [
            { includeLocations: null },
            { includeLocations: { $exists: false } },
            { includeLocations: shopLocation },
          ]
        },
        // Has excluded location undefined or not includes the shop location.
        {
          $or: [
            { excludeLocations: null },
            { excludeLocations: { $exists: false } },
            { excludeLocations: { $nin: [shopLocation] } },
          ]
        },
      ]
    }

    // Query for active surveys.
    const surveys = SurveyModel.find(query, '_id title description questions')

    res.status(200).json({ success: 1, surveys })
  } catch (e) {
    res.status(500).json({ success: 0, message: e })
  }
}

export async function handlePost(req: Request, res: Response, next?: NextFunction) {
  try {
    // Get current shop.
    const { shop: shopDomain } = req.session

    // Get user response from POST body.
    const { data } = req.body

    if (!data || !data.answers || !data.surveyId) {
      throw new Error('Missing data!')
    }

    // Insert user response to database.
    const { answers, surveyId } = data

    SurveyResponseModel.create({ answers, surveyId, shopDomain }).then(console.error)

    return res.status(200).json({ success: 1 })
  } catch (e) {
    res.status(500).json({ success: 0, message: e })
  }
}
```

</details>

In the file above, I've created the API endpoint /api/survey that supports two request methods: GET for retrieving active surveys and POST for saving user responses.

That's enough for the server side. It's time to write code for the client side.

Because stakeholders might want to display the survey in multiple places, We will create storage to save the survey content instead of storing it in the component state. The storage below extends the base storage class I created in [this proposal](../../refactor-pagefly-applying-oop/apply-the-oop-concept-to-refactor-pagefly/storage-mechanism.md).

If you want, you can create storage the way you like. But, make sure that every component needs to access and mutate the data via predefined methods bound to the data instead of the direct way via object properties. This behavior ensures the safety of the data.

<details>

<summary></summary>



</details>

|                           Current step                          |
| :-------------------------------------------------------------: |
| [5.-start-coding.md](../processes/5.-start-coding.md "mention") |
